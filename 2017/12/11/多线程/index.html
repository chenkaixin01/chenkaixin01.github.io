






<!doctype html>
<html lang="zh-CN">
<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="author" content="陈锴鑫">
  
  
  
  
    <meta name="description" content="概念线程进程中负责程序执行的执行单元，一个进程至少有一一个线程。
多线程解决多任务同时执行的需求 ，合理使用CPU资源。多线程的运行时根据CPU切换完成，如何切换由CPU决定，因此多线程运行具有不确定性
创建线程继承Thread类，扩展线程123456789class DemoThread extends Thread &#123;     @Override    public void ...">
  
  <title>多线程 [ 陈锴鑫 ]</title>
  
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
  <link rel="stylesheet" href="/css/random.css">
<link rel="stylesheet" href="/css/vegas.min.css">
<link rel="stylesheet" href="/css/highlight-railscasts.css">
<link rel="stylesheet" href="/css/jquery.fancybox.css">
<link rel="stylesheet" href="/css/iconfont/iconfont.css">
<link rel="stylesheet" href="/css/jquery.fancybox-thumbs.css">
<link rel="stylesheet" href="/css/plyr.css">
  
</head>

<body>
<div class="side-navigate hide-area">
  
    <div class="item prev">
      <a href="/2017/12/11/循环链表/">
        <div class="item-icon"></div>
      </a>
      <div class="item-title">
        循环链表
      </div>
    </div>
  
  
    <div class="item next">
      <a href="/2017/12/11/双向链表/">
        <div class="item-icon"></div>
      </a>
      <div class="item-title">
        双向链表
      </div>
    </div>
  
</div>
<div id="outer-container" class="hide-area">
<div id="container">
  <div id="menu-outer" class="slide-down">
    <div id="menu-inner">
      <div id="brand">
        
        <a onClick="openUserCard()">
          <img id="avatar" src="/images/casper.png"/>
          <div id="homelink">陈锴鑫</div>
        </a>
      </div>
      <div id="menu-list">
        <ul>
        
        
          
            <li>
          
            <a href="/index.html">首页</a>
            
          </li>
        
          
            <li>
          
            <a href="/archives">文章</a>
            
          </li>
        
          
            <li>
          
            <a href="/tags">标签</a>
            
          </li>
        
          
            <li>
          
            <a href="/categories">分类</a>
            
          </li>
        
          
            <li>
          
            <a href="/about">关于</a>
            
          </li>
        
          
            <li>
          
            <a href="https://github.com/chenkaixin01">Github</a>
            
          </li>
        
        </ul>
      </div>
      <div id="show-menu">
        <button>Menu</button>
      </div>
    </div>
  </div>

  <div id="content-outer">
    <div id="content-inner">
      
      
  <article id="post">
    <h1>多线程</h1>
    <p class="page-title-sub">
      <span id = "post-title-date">撰写于 2017-12-11</span>
      
        <span id = "post-title-updated">修改于 2017-09-26</span>
      
      
      <span id = "post-title-categories">分类
      
      
        
        
        <a href="/categories/多线程/">多线程</a>
      
        
          /
        
        
        <a href="/categories/多线程/多线程/">多线程</a>
      
      </span>
      
      
      <span id = "post-title-tags">
      标签
      
      
        
        
        <a href="/tags/多线程/">多线程</a>
      
        
          /
        
        
        <a href="/tags/线程/">线程</a>
      
      </span>
      
    </p>
    
    <h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>进程中负责程序执行的执行单元，一个进程至少有一一个线程。</p>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>解决多任务同时执行的需求 ，合理使用CPU资源。多线程的运行时根据CPU切换完成，如何切换由CPU决定，因此多线程运行具有不确定性</p>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><h4 id="继承Thread类，扩展线程"><a href="#继承Thread类，扩展线程" class="headerlink" title="继承Thread类，扩展线程"></a>继承Thread类，扩展线程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class DemoThread extends Thread &#123; </div><div class="line">    @Override</div><div class="line">    public void <span class="function"><span class="title">run</span></span>() &#123; </div><div class="line">        super.run();</div><div class="line">        // Perform time-consuming operation... </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">DemoThread t = new DemoThread(); </div><div class="line">t.start();</div></pre></td></tr></table></figure>
<ul>
<li>继承Thread类，扩展线程</li>
<li>创建线程对象，用start()方法启动线程。</li>
</ul>
<h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"> public class Test2 &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        //创建对象</div><div class="line">        MyRunnable mr = new MyRunnable();</div><div class="line">        Thread t = new Thread(mr);</div><div class="line">        //启动</div><div class="line">        t.start();</div><div class="line">        try&#123;</div><div class="line">            <span class="keyword">for</span>(int i = 0;i &lt; 10;i++)&#123;</div><div class="line">                Thread.sleep(1000);</div><div class="line">                System.out.println(<span class="string">"main:"</span> + i);</div><div class="line">               &#125;</div><div class="line">       &#125;catch(Exception e)&#123;&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">         /**</div><div class="line">         * 使用实现Runnable接口的方式实现多线程</div><div class="line">         */</div><div class="line"></div><div class="line">public class MyRunnable implements Runnable &#123;</div><div class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;</div><div class="line">        try&#123;</div><div class="line">            <span class="keyword">for</span>(int i = 0;i &lt; 10;i++)&#123;</div><div class="line">                Thread.sleep(1000);</div><div class="line">                System.out.println(<span class="string">"run:"</span> + i);</div><div class="line">            &#125;</div><div class="line">        &#125;catch(Exception e)&#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>实现Runnable接口</li>
<li>使用new Thread(Runnable实现对象)，创建线程</li>
</ul>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="线程和进程之间的区别"><a href="#线程和进程之间的区别" class="headerlink" title="线程和进程之间的区别"></a>线程和进程之间的区别</h4><p>一个进程时一个独立的运行环境，它可以被看作一个程序或者一个应用。线程是在进程中执行的一个任务。线程是进程的子集，一个进程可以有很多线程，每条线程并行执行不同的任务。不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间，每个线程都拥有的栈内存来存储本地数据。</p>
<h4 id="如何在Java中实现线程"><a href="#如何在Java中实现线程" class="headerlink" title="如何在Java中实现线程"></a>如何在Java中实现线程</h4><p>1、继承Thread类，重写方法。<br>2、实现Runnable接口。</p>
<h4 id="start-方法与Run-方法的区别"><a href="#start-方法与Run-方法的区别" class="headerlink" title="start()方法与Run()方法的区别"></a>start()方法与Run()方法的区别</h4><p>调用start()方法是启动新线程，线程之间没有确定执行顺序，而是CPU决定的；如果直接调用run方法，则是像普通方法一样顺序执行。</p>
<h3 id="多线程优缺点"><a href="#多线程优缺点" class="headerlink" title="多线程优缺点"></a>多线程优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>适当提高程序的执行效率（多个线程并行）</li>
<li>适当提高资源利用率<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4></li>
<li>占用一定的内存空间</li>
<li>线程越多CPU调度开销越大</li>
<li>程序复杂度上升</li>
</ul>
<h3 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h3><h4 id="图"><a href="#图" class="headerlink" title="图"></a>图</h4><p><img src="/images/多线程状态转换图.jpg" alt="多线程状态转换图"></p>
<h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>1、新生状态<br>2、就绪状态<br>3、运行状态<br>4、阻塞状态<br>阻塞状态是由于正在运行的线程未结束，暂时让出了CPU<br>5、死亡状态<br>1、 run方法正常退出而自然死亡，<br>2、 一个未捕获的异常终止了run方法而使线程猝死。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait(),notify(),notifyAll()"></a>wait(),notify(),notifyAll()</h4><h5 id="wait"><a href="#wait" class="headerlink" title="wait():"></a>wait():</h5><p>导致线程进入等待状态，直到它被其他线程通过notify()或者notifyAll()唤醒，该方法只能在同步方法中调用。</p>
<h5 id="notify"><a href="#notify" class="headerlink" title="notify():"></a>notify():</h5><p>随机选择一个在该对象上调用wait()方法的线程，解除其阻塞状态，该方法只能在同步方法或者同步块内部调用。</p>
<h5 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll():"></a>notifyAll():</h5><p>解除所有那些在该对象上调用wait方法的线程的阻塞状态，同样方法只能在同步方法或者同步块内部调用。</p>
<h4 id="wait-与sleep-long-time-的区别"><a href="#wait-与sleep-long-time-的区别" class="headerlink" title="wait()与sleep(long time)的区别"></a>wait()与sleep(long time)的区别</h4><p>sleep()：在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），该线程不丢失任何监视器的所属权，sleep() 是 Thread 类专属的静态方法，针对一个特定的线程。<br>wait() 方法使实体所处线程暂停执行，从而使对象进入等待状态，直到被 notify() 方法通知或者 wait() 的等待的时间到。sleep() 方法使持有的线程暂停运行，从而使线程进入休眠状态，直到用 interrupt 方法来打断他的休眠或者 sleep 的休眠的时间到。<br>wait() 方法进入等待状态时会释放同步锁，而 sleep() 方法不会释放同步锁。所以，当一个线程无限 sleep 时又没有任何人去 interrupt 它的时候，程序就产生大麻烦了，notify() 是用来通知线程，但在 notify() 之前线程是需要获得 lock 的。另个意思就是必须写在 synchronized(lockobj) {…} 之中。wait() 也是这个样子，一个线程需要释放某个 lock，也是在其获得 lock 情况下才能够释放，所以 wait() 也需要放在 synchronized(lockobj) {…} 之中。</p>
<h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><p>volatile是一个特殊的修饰符，只有成员变量才能使用，使变为可见，保证下一个读取操作会在前一个写操作后发生。</p>
<h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p>将一个线程插入到另一个线程中执行。</p>
<h4 id="Thread-yield"><a href="#Thread-yield" class="headerlink" title="Thread.yield()"></a>Thread.yield()</h4><p>线程放弃运行，将CPU控制权让出。<br>yield() 方法让出控制权后，还有可能马上被系统的调度机制选中来运行</p>

  </article>
  <div class="random-toc-area">
  <button class="btn-hide-toc btn-hide-toc-show" style="display: none" onclick="TOCToggle()">显示目录</button>
  <button class="btn-hide-toc btn-hide-toc-hide" onclick="TOCToggle()">隐藏目录</button>
  <div class="random-toc">
    <h2>目录</h2>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#概念"><span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#线程"><span class="toc-text">线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多线程"><span class="toc-text">多线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建线程"><span class="toc-text">创建线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#继承Thread类，扩展线程"><span class="toc-text">继承Thread类，扩展线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现Runnable接口"><span class="toc-text">实现Runnable接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#问题"><span class="toc-text">问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#线程和进程之间的区别"><span class="toc-text">线程和进程之间的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何在Java中实现线程"><span class="toc-text">如何在Java中实现线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#start-方法与Run-方法的区别"><span class="toc-text">start()方法与Run()方法的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程优缺点"><span class="toc-text">多线程优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#优点"><span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺点"><span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程状态转换"><span class="toc-text">线程状态转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#图"><span class="toc-text">图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#状态"><span class="toc-text">状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法"><span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#wait-notify-notifyAll"><span class="toc-text">wait(),notify(),notifyAll()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#wait"><span class="toc-text">wait():</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#notify"><span class="toc-text">notify():</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#notifyAll"><span class="toc-text">notifyAll():</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wait-与sleep-long-time-的区别"><span class="toc-text">wait()与sleep(long time)的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile关键字"><span class="toc-text">volatile关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#join"><span class="toc-text">join()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Thread-yield"><span class="toc-text">Thread.yield()</span></a></li></ol></li></ol>
  </div>
</div>

  
<nav id="pagination">
  
    <a href="/2017/12/11/循环链表/" class="prev">&larr; 上一篇 循环链表</a>
  

  

  
    <a href="/2017/12/11/双向链表/" class="next">下一篇 双向链表 &rarr;</a>
  
</nav>

  <!-- JiaThis Button BEGIN -->

<!-- JiaThis Button END -->


      
      
    </div>
  </div>

  <div id="bottom-outer">
    <div id="bottom-inner">
      Site by 陈锴鑫 using
      <a href="http://hexo.io">Hexo</a> & <a href="https://github.com/stiekel/hexo-theme-random">Random</a>
      <br>
      
    </div>
  </div>
</div>

</div>


<div id="user-card">
  <div class="center-field">
    <img class="avatar" src="/images/casper.png">
    <p id="description"></p>
    <ul class="social-icon">
  
  
    <li>
      <a href="https://github.com/chenkaixin01">
        
          <i class="icon iconfont github">&#xe606;</i>
        
      </a>
    </li>
  
    <li>
      <a href="http://blog.csdn.net/qq_34332035/">
        
          CSDN
        
      </a>
    </li>
  
</ul>
  </div>
</div>


<div id="btn-view">Hide</div>

<script>
// is trigger analytics / tongji script
var isIgnoreHost = false;

if(window && window.location && window.location.host) {
  isIgnoreHost = ["localhost","127.0.0.1"].some(function(address){
    return 0 === window.location.host.indexOf(address);
  });
}

var isTriggerAnalytics = !( true && isIgnoreHost );

</script>




  
  
    <script src="/js/jquery-2.2.3.min.js"></script>
  
    <script src="/js/vegas.min.js"></script>
  
    <script src="/js/random.js"></script>
  
    <script src="/js/highlight.pack.js"></script>
  
    <script src="/js/jquery.mousewheel.pack.js"></script>
  
    <script src="/js/jquery.fancybox.pack.js"></script>
  
    <script src="/js/jquery.fancybox-thumbs.js"></script>
  
    <script src="/js/plyr.js"></script>
  

<script>

  // fancybox
  var backgroundImages = [];
  
  $('#post').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox') || $(this).parent().hasClass('fancybox-thumb')) return;
      var alt = this.alt || this.title;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'post' + i);
    });
  });
  $(".fancybox").fancybox();

var vegasConfig = {"preload­Image":true,"transition":["slideLeft2","slideRight2","flash2"],"timer":true,"delay":5000,"shuffle":true,"count":28};
var unsplashConfig = {"gravity":"north"};
// is show background images
var turnoffBackgroundImage = false;



  turnoffBackgroundImage = true;


var backgroundColor = "34495E";

$(".fancybox-thumb").fancybox({
  prevEffect: 'none',
  nextEffect: 'none',
  helpers: {
    title: {
      type: 'outside'
    },
    thumbs: {
      width: 50,
      height: 50
    }
  }
});

// show video with plyr
$(".video-container iframe").each(function(i){
  var url = $(this).attr('src');
  var id = url.split('/').pop();
  var plyrContainer = document.createElement('div');
  plyrContainer.className = 'plyr';
  var plyrElement = document.createElement('div');
  plyrElement.dataset.videoId = id;
  switch(true) {
    case url.search('youtube.com') >= 0:
      plyrElement.dataset.type = 'youtube';
      break;
    case url.search('vimeo.com') >= 0:
      plyrElement.dataset.type = 'vimeo';
      break;
    default:
      return;
  };
  plyrContainer.appendChild(plyrElement);
  $(this).parent().html(plyrContainer);
});
plyr.setup('.plyr', {iconUrl: '/css/sprite.svg'});
</script>
</body>
</html>

